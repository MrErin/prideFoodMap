---
phase: 03-search-filter-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stateManager.ts
  - src/search.ts
  - src/emptyState.ts
  - src/cards.ts
  - src/cards.css
  - index.html
  - src/main.ts
autonomous: true

must_haves:
  truths:
    - "User can type in search box and cards filter by location name in real-time"
    - "Empty state message appears when no cards match search query"
    - "Clear/reset button appears when search has text, disappears when empty"
    - "Screen readers announce 'No locations match your search' when empty state shows"
    - "Pressing Escape while searching clears the search and shows all cards"
  artifacts:
    - path: "src/search.ts"
      provides: "Debounced search input handler"
      exports: ["setupSearchInput", "debounce"]
      min_lines: 30
    - path: "src/emptyState.ts"
      provides: "Empty state UI component with ARIA live region"
      exports: ["createEmptyState", "updateEmptyState"]
      min_lines: 25
    - path: "src/stateManager.ts"
      provides: "Extended state with searchQuery field"
      exports: ["FilterState", "setSearchQuery"]
      contains: "searchQuery"
    - path: "src/cards.ts"
      provides: "filterCards function for search filtering"
      exports: ["filterCards"]
    - path: "index.html"
      contains: "search-input"
      contains: "search-reset"
  key_links:
    - from: "src/search.ts"
      to: "src/stateManager.ts"
      via: "setSearchQuery() call"
      pattern: "stateManager\\.setSearchQuery"
    - from: "src/main.ts"
      to: "src/search.ts"
      via: "setupSearchInput() call"
      pattern: "setupSearchInput"
    - from: "src/cards.ts"
      to: "DOM"
      via: "filterCards() toggles .hidden class"
      pattern: "\\.classList\\.(add|remove)\\('hidden'\\)"
---

<objective>
Implement real-time text search with debounced input, empty state messaging, and clear/reset button for filtering location cards by name.

**Purpose:** Users need to quickly find specific locations by name without scrolling through all cards.

**Output:**
- search.ts module with debounced input handler
- emptyState.ts module with ARIA live region
- Extended StateManager with FilterState (searchQuery)
- filterCards function in cards.ts
- Search input UI in HTML
</objective>

<execution_context>
@/home/erinmeaker/.claude/get-shit-done/workflows/execute-plan.md
@/home/erinmeaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-filter-integration/03-RESEARCH.md
@.planning/phases/02-card-list-bi-directional-sync/02-03-SUMMARY.md

# Existing patterns from Phase 2
@src/stateManager.ts (Observer pattern, SelectionState interface)
@src/cards.ts (createCardElement, renderCards, updateCardSelection)
@src/map.ts (layer control overlay names)
@src/cards.css (card styles, .hidden class will be added)
@src/main.ts (StateManager subscription pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend StateManager with FilterState and setSearchQuery method</name>
  <files>src/stateManager.ts</files>
  <action>
    Extend the existing SelectionState interface to create FilterState:
    1. Create new FilterState interface that extends SelectionState with searchQuery: string field
    2. Add setSearchQuery(query: string): void method to StateManager class
    3. Initialize state with searchQuery: '' (empty string)
    4. Only notify listeners when searchQuery actually changes (same pattern as setSelected)

    DO NOT modify existing SelectionState - it should remain as is for backward compatibility.
    DO NOT remove or change existing methods (getState, setSelected, clearSelection, subscribe, notify).

    Implementation pattern (follow existing setSelected pattern):
    ```typescript
    setSearchQuery(query: string): void {
      if (this.state.searchQuery !== query) {
        this.state.searchQuery = query;
        this.notify();
      }
    }
    ```

    StateManager state type should change from SelectionState to FilterState.
  </action>
  <verify>npm run build succeeds with no TypeScript errors</verify>
  <done>FilterState interface exists with searchQuery field, setSearchQuery method notifies only on value change</done>
</task>

<task type="auto">
  <name>Task 2: Create emptyState.ts module with ARIA live region</name>
  <files>src/emptyState.ts</files>
  <action>
    Create a new module for empty state UI with accessibility:
    1. Export createEmptyState(containerSelector: string): HTMLElement function that creates empty state div
    2. Empty state should have: id="empty-state", class="hidden", role="status"
    3. Export updateEmptyState(isEmpty: boolean, query: string = ''): void function
    4. When isEmpty=true: remove 'hidden' class, set aria-live="polite", set text content
    5. When isEmpty=false: add 'hidden' class, remove aria-live attribute
    6. Text content should be "No locations match your search." when query provided

    Follow ARIA live region pattern from research:
    - Use aria-live="polite" (not "assertive") to avoid interrupting screen readers
    - Set content dynamically via textContent, not innerHTML
    - Only set aria-live when showing (remove when hiding to prevent stale announcements)

    Reference: MDN ARIA Live Regions guide (in research doc)
  </action>
  <verify>npm run build succeeds, exports createEmptyState and updateEmptyState</verify>
  <done>Empty state element creates with correct ARIA attributes, updateEmptyState toggles visibility and announcements</done>
</task>

<task type="auto">
  <name>Task 3: Create search.ts module with debounced input handler</name>
  <files>src/search.ts</files>
  <action>
    Create a new module for search input handling:
    1. Export debounce<T extends (...args: any[]) => void>(fn: T, delay: number): (...args: Parameters<T>) => void utility function
    2. Use ReturnType<typeof setTimeout> | undefined for timer variable type
    3. Export setupSearchInput(inputElement: HTMLInputElement, resetButton: HTMLElement, stateManager: StateManager): void function
    4. Wrap stateManager.setSearchQuery in 300ms debounce
    5. Add 'input' event listener to inputElement
    6. Add 'click' listener to resetButton that clears input.value and calls setSearchQuery('')

    Debounce implementation (from research):
    ```typescript
    function debounce<T extends (...args: any[]) => void>(
      fn: T,
      delay: number
    ): (...args: Parameters<T>) => void {
      let timer: ReturnType<typeof setTimeout> | undefined;
      return function (...args: Parameters<T>) {
        clearTimeout(timer);
        timer = setTimeout(() => {
          fn.apply(this, args);
        }, delay);
      };
    }
    ```

    DO NOT use any external library - this is a standard pattern.
    DO NOT add any other functionality - keep module focused on search input handling.
  </action>
  <verify>npm run build succeeds, debounce function accepts generic function type</verify>
  <done>Debounce function works, setupSearchInput wires up input and reset button with 300ms delay</done>
</task>

<task type="auto">
  <name>Task 4: Add filterCards function and .hidden CSS class to cards.ts</name>
  <files>src/cards.ts</files>
  <action>
    Add search filtering to cards module:
    1. Export filterCards(cards: HTMLElement[], searchQuery: string): void function
    2. Query card name using .querySelector('.card-name')?.textContent
    3. Use toLocaleLowerCase() for case-insensitive matching (international character support)
    4. Add 'hidden' class to non-matching cards, remove from matching cards
    5. Set aria-hidden="true" on hidden cards, aria-hidden="false" on visible cards
    6. Call updateEmptyState(isEmpty) from emptyState.ts based on visible count

    Implementation pattern (from research):
    ```typescript
    export function filterCards(cards: HTMLElement[], searchQuery: string): void {
      const query = searchQuery.toLocaleLowerCase().trim();
      cards.forEach((card) => {
        const name = card.querySelector('.card-name')?.textContent ?? '';
        const matches = name.toLocaleLowerCase().includes(query);
        if (matches) {
          card.classList.remove('hidden');
          card.setAttribute('aria-hidden', 'false');
        } else {
          card.classList.add('hidden');
          card.setAttribute('aria-hidden', 'true');
        }
      });
      const visibleCount = cards.filter((c) => !c.classList.contains('hidden')).length;
      updateEmptyState(visibleCount === 0, searchQuery);
    }
    ```

    DO NOT remove cards from DOM - use CSS class toggling (maintains event listeners).
    DO NOT modify existing createCardElement, renderCards, or updateCardSelection functions.

    Import updateEmptyState from './emptyState.ts'.
  </action>
  <verify>npm run build succeeds, filterCards exported with correct signature</verify>
  <done>filterCards function toggles .hidden class and aria-hidden attributes based on name match</done>
</task>

<task type="auto">
  <name>Task 5: Add search UI HTML and CSS styles</name>
  <files>index.html, src/cards.css</files>
  <action>
    Add search input UI to HTML:
    1. In index.html, add search-container div before #card-list (inside main)
    2. Add input type="text" id="search-input" with placeholder="Search locations..."
    3. Add button id="search-reset" with text content "Clear" (or X icon)
    4. Set aria-label="Search locations" on input, aria-label="Clear search" on button
    5. Add empty-state div with id="empty-state", class="hidden", role="status"

    Add CSS styles to cards.css:
    1. .search-container: flex display, gap: 0.5rem, padding: 1rem, align-items: center
    2. #search-input: flex: 1, padding: 0.5rem, border: 1px solid #d1d5db, border-radius: 4px
    3. #search-reset: padding: 0.5rem 1rem, background: #6b7280, color: white, border: none, border-radius: 4px, cursor: pointer
    4. #search-reset.hidden: display: none
    5. #empty-state: text-align: center, padding: 2rem, color: #6b7280
    6. #empty-state.hidden: display: none
    7. .card.hidden: display: none (for filtering)

    Styles should match existing card design (gray/blue color scheme).
    Reset button should be subtle (gray background, white text).
  </action>
  <verify>npm run build succeeds, HTML validates, search UI elements styled</verify>
  <done>Search input and reset button visible above card list, empty state styled, .hidden class defined</done>
</task>

<task type="auto">
  <name>Task 6: Wire up search in main.ts with StateManager subscription</name>
  <files>src/main.ts</files>
  <action>
    Connect search functionality to main application:
    1. Import setupSearchInput from './search.ts', filterCards from './cards.ts', createEmptyState from './emptyState.ts'
    2. Call createEmptyState('#empty-state') after renderCards to create empty state element
    3. Get search input and reset button elements by ID after DOMContentLoaded
    4. Call setupSearchInput(input, resetButton, stateManager) to wire up event listeners
    5. Add StateManager subscription that calls filterCards when searchQuery changes
    6. Get all cards with querySelectorAll('.card') and pass to filterCards

    StateManager subscription pattern (follow existing pattern):
    ```typescript
    stateManager.subscribe((state) => {
      const cards = document.querySelectorAll<HTMLElement>('.card');
      filterCards(Array.from(cards), state.searchQuery);
    });
    ```

    DO NOT modify existing card click handlers or marker click handlers.
    DO NOT modify existing Escape key handler - it should already work with StateManager.clearSelection().

    The search subscription should be separate from the existing selection subscription.
  </action>
  <verify>npm run build succeeds, search input triggers filtering with 300ms debounce</verify>
  <done>Typing in search input filters cards in real-time, clear button resets search, empty state shows when no matches</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. Build succeeds: `npm run build`
2. Search input filters cards by location name as you type
3. Empty state message appears when search returns no results
4. Clear button appears when search has text, disappears when empty
5. Pressing Escape clears selection (existing behavior) - search should remain active
6. Screen readers announce empty state message

Manual verification in browser:
- Load page, type "fridge" in search - only fridge cards show
- Type "xyz" - empty state appears with message
- Click Clear button - all cards show, empty state hides
- Verify reset button is hidden when search is empty
</verification>

<success_criteria>
Phase 03 Plan 01 is complete when:

1. Text search box filters cards by location name in real-time (SRCH-01)
2. Empty state message displays when search returns no results (SRCH-03)
3. Clear/reset button appears when search is active to restore full card list (SRCH-04)
4. Debounce delay is 300ms (prevents excessive DOM updates)
5. All cards use .hidden class (not removed from DOM)
6. Empty state has aria-live="polite" for screen reader announcements
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-filter-integration/03-01-SUMMARY.md`
</output>

---
phase: 03-search-filter-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stateManager.ts
autonomous: true

must_haves:
  truths:
    - "StateManager can store and notify search query state changes"
    - "FilterState interface extends SelectionState with searchQuery field"
    - "setSearchQuery method only notifies listeners when value actually changes"
    - "Existing SelectionState behavior remains unchanged (backward compatible)"
  artifacts:
    - path: "src/stateManager.ts"
      provides: "Extended state with FilterState (searchQuery field)"
      exports: ["FilterState", "setSearchQuery"]
      contains: "searchQuery"
      min_lines: 40
  key_links:
    - from: "src/stateManager.ts"
      to: "SelectionState"
      via: "FilterState extends SelectionState"
      pattern: "interface FilterState extends SelectionState"
    - from: "src/stateManager.ts"
      to: "listeners"
      via: "notify() called only when searchQuery changes"
      pattern: "this\\.notify\\(\\)"
---

<objective>
Extend StateManager with FilterState foundation for search functionality, adding searchQuery field and setSearchQuery method while maintaining backward compatibility with existing SelectionState.

**Purpose:** Create the state foundation that search and layer filtering will build upon, extending the existing Observer pattern without breaking current selection functionality.

**Output:**
- FilterState interface extending SelectionState with searchQuery field
- setSearchQuery method with change-detection notification
- StateManager using FilterState instead of SelectionState
</objective>

<execution_context>
@/home/erinmeaker/.claude/get-shit-done/workflows/execute-plan.md
@/home/erinmeaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-filter-integration/03-RESEARCH.md

# Existing patterns from Phase 2
@src/stateManager.ts (Observer pattern, SelectionState interface, setSelected pattern)
@.planning/phases/02-card-list-bi-directional-sync/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend StateManager with FilterState and setSearchQuery method</name>
  <files>src/stateManager.ts</files>
  <action>
    Extend the existing SelectionState interface to create FilterState:
    1. Create new FilterState interface that extends SelectionState with searchQuery: string field
    2. Add setSearchQuery(query: string): void method to StateManager class
    3. Initialize state with searchQuery: '' (empty string)
    4. Only notify listeners when searchQuery actually changes (same pattern as setSelected)
    5. Change StateManager state type from SelectionState to FilterState

    DO NOT modify existing SelectionState - it should remain as is for backward compatibility.
    DO NOT remove or change existing methods (getState, setSelected, clearSelection, subscribe, notify).

    Implementation pattern (follow existing setSelected pattern):
    ```typescript
    setSearchQuery(query: string): void {
      if (this.state.searchQuery !== query) {
        this.state.searchQuery = query;
        this.notify();
      }
    }
    ```

    The state initialization should be:
    ```typescript
    private state: FilterState = {
      selectedId: null,
      searchQuery: ''
    };
    ```
  </action>
  <verify>npm run build succeeds with no TypeScript errors</verify>
  <done>FilterState interface exists with searchQuery field, setSearchQuery method notifies only on value change, state uses FilterState type</done>
</task>

<task type="auto">
  <name>Task 2: Add FilterState export and verify backward compatibility</name>
  <files>src/stateManager.ts</files>
  <action>
    Ensure proper TypeScript exports and compatibility:
    1. Export FilterState interface so other modules can import it
    2. Verify that existing SelectionState usage still works (it's now the base interface)
    3. Add JSDoc comment to FilterState explaining it extends SelectionState for filtering
    4. Add JSDoc comment to setSearchQuery explaining the change-detection notification

    Export statement (add to top of file):
    ```typescript
    export interface FilterState extends SelectionState {
      searchQuery: string;
    }
    ```

    JSDoc for setSearchQuery:
    ```typescript
    /**
     * Sets the search query and notifies listeners if value changed.
     * @param query - The new search query string
     */
    setSearchQuery(query: string): void {
      // ... implementation
    }
    ```

    DO NOT modify existing method implementations - only add exports and documentation.
  </action>
  <verify>npm run build succeeds, FilterState is exported, existing SelectionState imports still work</verify>
  <done>FilterState exported, JSDoc comments added, existing code still compiles without changes</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. Build succeeds: `npm run build`
2. FilterState interface is exported and extends SelectionState
3. setSearchQuery method exists and works correctly
4. Existing SelectionState usage in main.ts still works (no breaking changes)
5. StateManager state type is FilterState

TypeScript verification:
- Check that FilterState can be imported from './stateManager.ts'
- Check that state.searchQuery is typed as string
- Check that existing state.selectedId still works (string | null)
</verification>

<success_criteria>
Phase 03 Plan 01 is complete when:

1. FilterState interface extends SelectionState with searchQuery field
2. setSearchQuery method notifies listeners only when searchQuery value changes
3. StateManager uses FilterState as its state type
4. Existing SelectionState-based code continues to work without modification
5. FilterState is exported for use by other modules
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-filter-integration/03-01-SUMMARY.md`
</output>

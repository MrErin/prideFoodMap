---
phase: 03-search-filter-integration
plan: 03
type: execute
wave: 2
depends_on: ['01', '02']
files_modified:
  - src/stateManager.ts
  - src/map.ts
  - src/cards.ts
  - src/main.ts
autonomous: true

must_haves:
  truths:
    - "When user unchecks layer in map control, corresponding cards are hidden"
    - "When user checks layer in map control, corresponding cards are shown"
    - "Layer filtering and search filtering work together (AND logic: both must match)"
    - "Cards respect both search query and layer visibility simultaneously"
    - "Layer event listeners are properly cleaned up on map teardown"
  artifacts:
    - path: "src/stateManager.ts"
      provides: "Extended FilterState with visibleLayers Set"
      exports: ["FilterState", "toggleLayer"]
      contains: "visibleLayers"
      min_lines: 50
    - path: "src/map.ts"
      provides: "Leaflet overlay event listeners for layer visibility"
      exports: ["setupLayerEventListeners"]
      contains: "overlayadd"
      contains: "overlayremove"
      min_lines: 40
    - path: "src/cards.ts"
      provides: "Extended filterCards that handles both search and layer filtering"
      exports: ["filterCards"]
      min_lines: 30
    - path: "src/main.ts"
      contains: "setupLayerEventListeners"
      contains: "layerNameMapping"
  key_links:
    - from: "src/map.ts"
      to: "Leaflet map"
      via: "overlayadd/overlayremove event listeners"
      pattern: "map\\.on\\('overlay(add|remove)'"
    - from: "src/map.ts"
      to: "src/stateManager.ts"
      via: "toggleLayer() call"
      pattern: "stateManager\\.toggleLayer"
    - from: "src/cards.ts"
      to: "src/stateManager.ts"
      via: "FilterState.visibleLayers in filterCards"
      pattern: "visibleLayers\\.has|Set<string>"
    - from: "src/main.ts"
      to: "src/map.ts"
      via: "setupLayerEventListeners() call"
      pattern: "setupLayerEventListeners"
---

<objective>
Connect Leaflet layer control changes to card visibility with proper event listener cleanup, enabling synchronized filtering between map layers and card list.

**Purpose:** When users toggle map layers (Community Fridge/Food Donation), the corresponding cards should show/hide to maintain consistency between map and list views.

**Output:**
- Extended FilterState with visibleLayers Set
- Layer event listeners in map.ts with cleanup function
- Extended filterCards function that composes search AND layer filters
- Layer name mapping in main.ts
</objective>

<execution_context>
@/home/erinmeaker/.claude/get-shit-done/workflows/execute-plan.md
@/home/erinmeaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-filter-integration/03-RESEARCH.md
@.planning/phases/03-search-filter-integration/03-01-SUMMARY.md
@.planning/phases/03-search-filter-integration/03-02-SUMMARY.md

# Existing patterns
@src/stateManager.ts (FilterState with searchQuery from 03-01, Observer pattern)
@src/map.ts (layer control with overlay names: "Community Fridge and Pantry Locations", "Food Donation Sites")
@src/cards.ts (filterCards from 03-02, will be extended)
@src/main.ts (StateManager subscription pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend FilterState with visibleLayers Set and toggleLayer method</name>
  <files>src/stateManager.ts</files>
  <action>
    Extend FilterState (from plan 03-01) with layer visibility:
    1. Add visibleLayers: Set<string> field to FilterState interface
    2. Initialize with both layers visible: new Set(['Community Fridge', 'Food Donation'])
    3. Add toggleLayer(layerName: string, isVisible: boolean): void method
    4. In toggleLayer: create new Set from current visibleLayers, add/remove layerName based on isVisible, only notify if size changes

    Update state initialization:
    ```typescript
    private state: FilterState = {
      selectedId: null,
      searchQuery: '',
      visibleLayers: new Set(['Community Fridge', 'Food Donation'])
    };
    ```

    Implementation pattern (from research):
    ```typescript
    toggleLayer(layerName: string, isVisible: boolean): void {
      const layers = new Set(this.state.visibleLayers);
      if (isVisible) {
        layers.add(layerName);
      } else {
        layers.delete(layerName);
      }
      if (layers.size !== this.state.visibleLayers.size ||
          ![...layers].every(l => this.state.visibleLayers.has(l))) {
        this.state.visibleLayers = layers;
        this.notify();
      }
    }
    ```

    IMPORTANT: Use Set<string> for visibleLayers (not array) for O(1) lookups.
    IMPORTANT: Create new Set instance before mutating (immutable pattern).
    IMPORTANT: Only notify when Set actually changes (prevents unnecessary re-renders).

    DO NOT modify existing SelectionState, FilterState.searchQuery, setSelected, setSearchQuery, or other methods.
  </action>
  <verify>npm run build succeeds, FilterState has visibleLayers Set, toggleLayer method exists</verify>
  <done>FilterState includes visibleLayers Set initialized with both categories, toggleLayer notifies on change</done>
</task>

<task type="auto">
  <name>Task 2: Add setupLayerEventListeners function to map.ts</name>
  <files>src/map.ts</files>
  <action>
    Create layer event listener setup with cleanup:
    1. Export setupLayerEventListeners(map: L.Map, stateManager: StateManager): () => void function
    2. Listen for 'overlayadd' event on map, extract e.name (layer name from control)
    3. Listen for 'overlayremove' event on map
    4. Map layer names to card categories: "Community Fridge and Pantry Locations" -> "Community Fridge", "Food Donation Sites" -> "Food Donation"
    5. Call stateManager.toggleLayer(category, isVisible) on events
    6. Return cleanup function that removes both event listeners

    Layer name mapping (from open question in research):
    ```typescript
    const layerNameMapping: Record<string, string> = {
      'Community Fridge and Pantry Locations': 'Community Fridge',
      'Food Donation Sites': 'Food Donation'
    };

    map.on('overlayadd', (e: L.LayersControlEvent) => {
      const category = layerNameMapping[e.name];
      if (category) {
        stateManager.toggleLayer(category, true);
      }
    });
    ```

    Store listeners in array for cleanup:
    ```typescript
    const cleanupFunctions: Array<() => void> = [];
    map.on('overlayadd', handler);
    cleanupFunctions.push(() => map.off('overlayadd', handler));
    // Same for overlayremove
    return () => cleanupFunctions.forEach(fn => fn());
    ```

    DO NOT modify existing initializeMap, addMarkersFromCSV, or other functions.
    DO NOT use polling - use event-driven pattern.

    Reference Leaflet docs: overlayadd/overlayremove events (in research doc).
  </action>
  <verify>npm run build succeeds, setupLayerEventListeners exported with correct signature</verify>
  <done>Function listens to overlayadd/overlayremove, maps layer names, calls toggleLayer, returns cleanup</done>
</task>

<task type="auto">
  <name>Task 3: Extend filterCards in cards.ts to handle layer filtering</name>
  <files>src/cards.ts</files>
  <action>
    Extend filterCards function (from 03-02) to compose search AND layer filters:
    1. Change signature to filterCards(cards: HTMLElement[], searchQuery: string, visibleLayers: Set<string>): void
    2. Query both .card-name and .badge for search and category matching
    3. Check if card category is in visibleLayers Set
    4. Card is visible ONLY if matchesSearch AND matchesLayer (AND logic)
    5. Update empty state based on final visible count

    Implementation pattern (from research):
    ```typescript
    export function filterCards(
      cards: HTMLElement[],
      searchQuery: string,
      visibleLayers: Set<string>
    ): void {
      const query = searchQuery.toLocaleLowerCase().trim();

      cards.forEach((card) => {
        const name = card.querySelector('.card-name')?.textContent ?? '';
        const category = card.querySelector('.badge')?.textContent ?? '';

        const matchesSearch = name.toLocaleLowerCase().includes(query);
        const matchesLayer = visibleLayers.has(category);

        if (matchesSearch && matchesLayer) {
          card.classList.remove('hidden');
          card.setAttribute('aria-hidden', 'false');
        } else {
          card.classList.add('hidden');
          card.setAttribute('aria-hidden', 'true');
        }
      });

      const visibleCount = cards.filter((c) => !c.classList.contains('hidden')).length;
      updateEmptyState(visibleCount === 0, searchQuery);
    }
    ```

    DO NOT use OR logic - both filters must pass for card to be visible.
    DO NOT modify existing createCardElement, renderCards, or updateCardSelection functions.
    DO NOT change updateEmptyState call - it should already be imported from 03-02.

    This composes with 03-02's filterCards - just adds the layer parameter.
  </action>
  <verify>npm run build succeeds, filterCards accepts visibleLayers Set parameter</verify>
  <done>filterCards checks both search match AND layer visibility before showing cards</done>
</task>

<task type="auto">
  <name>Task 4: Wire up layer event listeners in main.ts with extended subscription</name>
  <files>src/main.ts</files>
  <action>
    Connect layer filtering to main application:
    1. Import setupLayerEventListeners from './map.ts'
    2. After initializeMap(), call setupLayerEventListeners(map, stateManager)
    3. Store cleanup function for potential later use (not used now but good practice)
    4. Update StateManager subscription to pass visibleLayers to filterCards

    Updated subscription pattern (extend existing):
    ```typescript
    stateManager.subscribe((state) => {
      const cards = document.querySelectorAll<HTMLElement>('.card');
      filterCards(Array.from(cards), state.searchQuery, state.visibleLayers);
    });
    ```

    The subscription should trigger on BOTH searchQuery changes AND visibleLayers changes.

    DO NOT create separate subscriptions - use one subscription for all filter state.
    DO NOT modify existing card click handlers, marker click handlers, or Escape key handler.

    Get map instance from initializeMap - need to update initializeMap to return map:
    - Change InitializeMapResult interface to include map: L.Map
    - Return map in initializeMap return statement

    This is a minor extension to initializeMap - just add map to the return object.
  </action>
  <verify>npm run build succeeds, layer control toggles trigger card filtering</verify>
  <done>Unchecking "Community Fridge" layer hides fridge cards, checking shows them; search + layer filters compose correctly</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. Build succeeds: `npm run build`
2. Unchecking "Community Fridge and Pantry Locations" in map control hides all fridge cards
3. Checking "Community Fridge and Pantry Locations" shows all fridge cards
4. Same behavior for "Food Donation Sites"
5. Search + layer filtering compose: typing "fridge" then unchecking fridge layer shows no cards
6. Empty state appears when combined filters result in zero matches
7. Layer control and search filtering work independently but compose with AND logic

Manual verification in browser:
- Load page, uncheck "Community Fridge" layer - only donation cards show
- Type "donation" in search - only donation cards matching "donation" show
- Re-check "Community Fridge" layer - all fridge cards show (filtered by search if active)
- Uncheck both layers - empty state appears
</verification>

<success_criteria>
Phase 03 Plan 03 is complete when:

1. When map layer control toggles marker visibility, corresponding cards are hidden or shown (SRCH-02)
2. Layer filtering and search filtering compose with AND logic (both must match)
3. Leaflet overlayadd/overlayremove events are properly handled
4. Layer name mapping correctly maps overlay names to card categories
5. StateManager notifies listeners when visibleLayers changes
6. All cards respect both search query and layer visibility simultaneously
7. Depends on Plans 01 (FilterState) and 02 (filterCards foundation)
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-filter-integration/03-03-SUMMARY.md`
</output>

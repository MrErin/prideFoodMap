---
phase: 01-type-safety-test-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01", "02"]
files_modified:
  - src/test/map.test.ts
autonomous: true

must_haves:
  truths:
    - "Unit tests verify marker creation, coordinate validation, and CSV parsing for addMarkersFromCSV"
    - "Unit tests verify map initialization, tile loading, and layer control setup for initializeMap"
    - "Unit tests verify ARIA live region announcements trigger correctly for announce function"
    - "All new tests use real Leaflet instances (no mocking of Leaflet itself)"
  artifacts:
    - path: "src/test/map.test.ts"
      provides: "Comprehensive unit tests for map.ts functions"
      contains: "describe('addMarkersFromCSV')|describe('initializeMap')"
      min_lines: 200
  key_links:
    - from: "src/test/map.test.ts"
      to: "src/map.ts"
      via: "Import of addMarkersFromCSV, initializeMap, announce"
      pattern: "import.*from.*'\\.\\.\\/map\\.ts'"
    - from: "src/test/map.test.ts"
      to: "Leaflet library"
      via: "Direct import and usage (no mocking)"
      pattern: "import \\* as L from 'leaflet'"
---

<objective>
Add comprehensive unit tests for `addMarkersFromCSV`, `initializeMap`, and `announce` functions using real Leaflet instances.

Purpose: Achieve test coverage for core map functionality, ensuring marker creation, coordinate validation, map initialization, and accessibility announcements work correctly.

Output: Comprehensive unit tests covering marker creation, coordinate validation, map initialization, tile loading, layer controls, and ARIA announcements.
</objective>

<execution_context>
@/home/erinmeaker/.claude/get-shit-done/workflows/execute-plan.md
@/home/erinmeaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-type-safety-test-infrastructure/01-RESEARCH.md
@.planning/codebase/TESTING.md
@src/map.ts
@src/test/map.test.ts
</context>

<tasks>

<task type="auto">
  <name>Export addMarkersFromCSV and initializeMap for testing</name>
  <files>src/map.ts</files>
  <action>
    Export the addMarkersFromCSV function so it can be tested:

    Change line 61 from:
    ```typescript
    const addMarkersFromCSV = (
    ```
    To:
    ```typescript
    export const addMarkersFromCSV = (
    ```

    This function is already tested indirectly through initializeMap, but we need direct access for comprehensive unit testing.

    The initializeMap function is already exported (line 117).
  </action>
  <verify>
    Run `npx tsc --noEmit` - confirm export is valid
  </verify>
  <done>
    - addMarkersFromCSV is exported from src/map.ts
    - TypeScript compilation succeeds
  </done>
</task>

<task type="auto">
  <name>Add unit tests for addMarkersFromCSV function</name>
  <files>src/test/map.test.ts</files>
  <action>
    Add a new describe block for addMarkersFromCSV with comprehensive tests:

    ```typescript
    import * as L from 'leaflet';
    import { addMarkersFromCSV, MarkerData } from '../map.ts';

    describe('addMarkersFromCSV', () => {
      let layerGroup: L.LayerGroup;
      let icon: L.Icon;

      beforeEach(() => {
        // Create real Leaflet instances - no mocking needed
        layerGroup = L.layerGroup();
        icon = L.icon({
          iconUrl: 'test.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
        });
      });

      it('should create markers from valid CSV data', () => {
        const data: MarkerData[] = [
          {
            latitude: 40.7128,
            longitude: -74.006,
            locationName: 'Test Location',
            description: 'Test Description',
            street: '123 Main St',
            city: 'New York',
            state: 'NY',
            zip: '10001',
          },
        ];

        addMarkersFromCSV(data, layerGroup, icon, 'Test Layer');

        expect(layerGroup.getLayers()).toHaveLength(1);
        const marker = layerGroup.getLayers()[0] as L.Marker;
        expect(marker.getLatLng()).toEqual({ lat: 40.7128, lng: -74.006 });
      });

      it('should create markers with popup content', () => {
        const data: MarkerData[] = [
          {
            latitude: 40.7128,
            longitude: -74.006,
            locationName: 'Test Location',
            description: 'Test Description',
            street: '123 Main St',
            city: 'New York',
            state: 'NY',
            zip: '10001',
          },
        ];

        addMarkersFromCSV(data, layerGroup, icon, 'Test Layer');

        const marker = layerGroup.getLayers()[0] as L.Marker;
        const popup = marker.getPopup();
        expect(popup).toBeTruthy();
        expect(popup?.getContent()).toContain('Test Location');
        expect(popup?.getContent()).toContain('123 Main St');
      });

      it('should skip invalid coordinates (NaN)', () => {
        const data: MarkerData[] = [
          {
            latitude: NaN,
            longitude: -74.006,
            locationName: 'Invalid Location',
            street: '',
            city: '',
            state: '',
            zip: '',
          },
        ];

        addMarkersFromCSV(data, layerGroup, icon, 'Test Layer');

        expect(layerGroup.getLayers()).toHaveLength(0);
      });

      it('should skip zero coordinates', () => {
        const data: MarkerData[] = [
          {
            latitude: 0,
            longitude: 0,
            locationName: 'Zero Coordinates',
            street: '',
            city: '',
            state: '',
            zip: '',
          },
        ];

        addMarkersFromCSV(data, layerGroup, icon, 'Test Layer');

        expect(layerGroup.getLayers()).toHaveLength(0);
      });

      it('should handle multiple valid markers', () => {
        const data: MarkerData[] = [
          {
            latitude: 40.7128,
            longitude: -74.006,
            locationName: 'New York',
            street: '',
            city: '',
            state: '',
            zip: '',
          },
          {
            latitude: 34.0522,
            longitude: -118.2437,
            locationName: 'Los Angeles',
            street: '',
            city: '',
            state: '',
            zip: '',
          },
          {
            latitude: 41.8781,
            longitude: -87.6298,
            locationName: 'Chicago',
            street: '',
            city: '',
            state: '',
            zip: '',
          },
        ];

        addMarkersFromCSV(data, layerGroup, icon, 'Test Layer');

        expect(layerGroup.getLayers()).toHaveLength(3);
      });

      it('should handle markers with missing optional description', () => {
        const data: MarkerData[] = [
          {
            latitude: 40.7128,
            longitude: -74.006,
            locationName: 'Test Location',
            street: '',
            city: '',
            state: '',
            zip: '',
          },
        ];

        addMarkersFromCSV(data, layerGroup, icon, 'Test Layer');

        const marker = layerGroup.getLayers()[0] as L.Marker;
        expect(marker.getPopup()).toBeTruthy();
      });

      it('should add ARIA attributes to marker elements', async () => {
        const data: MarkerData[] = [
          {
            latitude: 40.7128,
            longitude: -74.006,
            locationName: 'Test Location',
            street: '',
            city: '',
            state: '',
            zip: '',
          },
        ];

        addMarkersFromCSV(data, layerGroup, icon, 'Test Layer');

        const marker = layerGroup.getLayers()[0] as L.Marker;

        // Manually trigger the 'add' event to simulate DOM addition
        marker.fire('add');

        await vi.waitFor(() => {
          const element = marker.getElement();
          expect(element).toBeTruthy();
          expect(element?.getAttribute('role')).toBe('button');
          expect(element?.getAttribute('aria-label')).toContain('Test Location');
          expect(element?.getAttribute('tabindex')).toBe('0');
        });
      });

      it('should filter out mix of valid and invalid coordinates', () => {
        const data: MarkerData[] = [
          {
            latitude: 40.7128,
            longitude: -74.006,
            locationName: 'Valid',
            street: '',
            city: '',
            state: '',
            zip: '',
          },
          {
            latitude: NaN,
            longitude: -74.006,
            locationName: 'Invalid',
            street: '',
            city: '',
            state: '',
            zip: '',
          },
          {
            latitude: 34.0522,
            longitude: -118.2437,
            locationName: 'Also Valid',
            street: '',
            city: '',
            state: '',
            zip: '',
          },
        ];

        addMarkersFromCSV(data, layerGroup, icon, 'Test Layer');

        expect(layerGroup.getLayers()).toHaveLength(2);
      });
    });
    ```

    Add this after the existing announce describe block.

    Reference: .planning/phases/01-type-safety-test-infrastructure/01-RESEARCH.md lines 316-375
  </action>
  <verify>
    Run `npm test` - all new addMarkersFromCSV tests should pass
  </verify>
  <done>
    - 8-10 test cases covering addMarkersFromCSV behavior
    - Tests cover: valid markers, popup content, invalid coordinates, multiple markers, missing description, ARIA attributes, mixed valid/invalid
    - All tests pass
  </done>
</task>

<task type="auto">
  <name>Add unit tests for initializeMap function</name>
  <files>src/test/map.test.ts</files>
  <action>
    Add a new describe block for initializeMap with comprehensive tests:

    ```typescript
    import { initializeMap } from '../map.ts';

    describe('initializeMap', () => {
      let mapContainer: HTMLElement;
      let fetchSpy: ReturnType<typeof vi.spyOn>;

      beforeEach(() => {
        // Create map container
        mapContainer = document.createElement('div');
        mapContainer.setAttribute('id', 'map');
        document.body.appendChild(mapContainer);

        // Mock fetch to avoid network requests
        const createMockResponse = (text: string): Partial<Response> => ({
          ok: true,
          status: 200,
          statusText: 'OK',
          text: () => Promise.resolve(text),
          headers: new Headers(),
          redirected: false,
          url: '',
          clone: () => ({} as Response),
          json: () => Promise.resolve({}),
          blob: () => Promise.resolve(new Blob()),
          formData: () => Promise.resolve(new FormData()),
          arrayBuffer: () => Promise.resolve(new ArrayBuffer(0)),
          body: null,
          bodyUsed: false,
        });

        const mockFridgeCSV = `latitude,longitude,locationName,description,street,city,state,zip
        35.0456,-85.2672,Chattanooga Fridge,Community fridge,123 Main St,Chattanooga,TN,37402`;

        const mockDonationCSV = `latitude,longitude,locationName,description,street,city,state,zip
        35.0556,-85.2572,Donation Site,Food donation,456 Oak Ave,Chattanooga,TN,37403`;

        fetchSpy = vi.spyOn(global, 'fetch').mockImplementation(
          async (input: RequestInfo | URL): Promise<Response> => {
            const url = typeof input === 'string' ? input : input.toString();
            if (url.includes('fridgePins.csv')) {
              return createMockResponse(mockFridgeCSV) as Response;
            }
            if (url.includes('donationPins.csv')) {
              return createMockResponse(mockDonationCSV) as Response;
            }
            return createMockResponse('') as Response;
          }
        );
      });

      afterEach(() => {
        fetchSpy.mockRestore();
        vi.restoreAllMocks();
        if (mapContainer.parentNode) {
          document.body.removeChild(mapContainer);
        }
      });

      it('should initialize map with tile layer', async () => {
        await expect(initializeMap()).resolves.not.toThrow();

        const mapContainer = document.getElementById('map');
        expect(mapContainer?.querySelector('.leaflet-map-pane')).toBeTruthy();
      });

      it('should create layer groups for fridges and donations', async () => {
        await initializeMap();

        const mapContainer = document.getElementById('map');
        const leafletContainer = mapContainer?.querySelector('.leaflet-map-pane');
        expect(leafletContainer).toBeTruthy();
      });

      it('should fit map bounds to markers', async () => {
        await initializeMap();

        const mapContainer = document.getElementById('map');
        expect(mapContainer?.querySelector('.leaflet-marker-icon')).toBeTruthy();
      });

      it('should add layer control to map', async () => {
        await initializeMap();

        const controlElement = document.querySelector('.leaflet-control-layers');
        expect(controlElement).toBeTruthy();
      });

      it('should add ARIA attributes to layer control', async () => {
        await initializeMap();

        await vi.waitFor(() => {
          const controlElement = document.querySelector('.leaflet-control-layers');
          expect(controlElement?.getAttribute('role')).toBe('group');
          expect(controlElement?.getAttribute('aria-label')).toBe('Map Layer Controls');
        }, { timeout: 1000 });
      });

      it('should handle CSV loading errors gracefully', async () => {
        fetchSpy.mockRestore();
        fetchSpy = vi.spyOn(global, 'fetch').mockRejectedValueOnce(new Error('Network error'));

        await expect(initializeMap()).rejects.toThrow();
      });

      it('should handle empty CSV data', async () => {
        fetchSpy.mockRestore();
        const createEmptyResponse = (): Partial<Response> => ({
          ok: true,
          status: 200,
          statusText: 'OK',
          text: () => Promise.resolve('latitude,longitude,locationName\n'),
          headers: new Headers(),
          redirected: false,
          url: '',
          clone: () => ({} as Response),
          json: () => Promise.resolve({}),
          blob: () => Promise.resolve(new Blob()),
          formData: () => Promise.resolve(new FormData()),
          arrayBuffer: () => Promise.resolve(new ArrayBuffer(0)),
          body: null,
          bodyUsed: false,
        });

        fetchSpy = vi.spyOn(global, 'fetch').mockResolvedValueOnce(
          createEmptyResponse() as Response
        ).mockResolvedValueOnce(
          createEmptyResponse() as Response
        );

        await expect(initializeMap()).resolves.not.toThrow();
      });
    });
    ```

    Reference: .planning/phases/01-type-safety-test-infrastructure/01-RESEARCH.md lines 403-431
  </action>
  <verify>
    Run `npm test` - all new initializeMap tests should pass
  </verify>
  <done>
    - 7-8 test cases covering initializeMap behavior
    - Tests cover: map initialization, tile layer, layer groups, bounds fitting, layer control, ARIA attributes, error handling, empty CSV
    - All tests pass
  </done>
</task>

</tasks>

<verification>
After completing the tasks, verify:

1. Test coverage: `npm run test:coverage` shows increased coverage for src/map.ts
2. All tests pass: `npm test` executes successfully
3. Tests use real Leaflet: No mocking of L.* objects
4. Tests use real timers: No vi.useFakeTimers() in new tests
</verification>

<success_criteria>
1. Unit tests exist for addMarkersFromCSV covering marker creation, coordinate validation, popup content, ARIA attributes
2. Unit tests exist for initializeMap covering map initialization, tile loading, layer controls, error handling
3. All new tests pass with real Leaflet instances and real timers
4. Test coverage for src/map.ts increases significantly
</success_criteria>

<output>
After completion, create `.planning/phases/01-type-safety-test-infrastructure/01-03-SUMMARY.md`
</output>

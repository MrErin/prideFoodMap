---
phase: 01-type-safety-test-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/map.ts
  - src/test/map.test.ts
autonomous: true

must_haves:
  truths:
    - 'No setTimeout calls remain in src/map.ts for DOM manipulation or timing'
    - 'Layer control accessibility enhancements use event-driven patterns'
    - 'Announcement function uses requestAnimationFrame instead of setTimeout'
    - 'Tests pass without using fake timers (vi.useFakeTimers)'
  artifacts:
    - path: 'src/map.ts'
      provides: 'Event-driven DOM timing for map initialization'
      excludes: 'setTimeout'
      contains: 'whenReady|requestAnimationFrame|MutationObserver'
    - path: 'src/test/map.test.ts'
      provides: 'Tests that work with real timers'
      excludes: 'vi.useFakeTimers|vi.advanceTimersByTime'
  key_links:
    - from: 'src/map.ts'
      to: 'Leaflet control elements'
      via: "Leaflet 'add' event on layer control"
      pattern: "\\.on\\('add'"
    - from: 'src/map.ts'
      to: 'ARIA announcements'
      via: 'requestAnimationFrame for DOM timing'
      pattern: 'requestAnimationFrame'
---

<objective>
Replace setTimeout-based DOM timing with event-driven patterns using Leaflet events and requestAnimationFrame.

Purpose: Eliminate race conditions from arbitrary setTimeout delays by using Leaflet's built-in event system for DOM detection and requestAnimationFrame for announcement timing.

Output: Event-driven code with no setTimeout calls in src/map.ts, tests passing without fake timers.
</objective>

<execution_context>
@/home/erinmeaker/.claude/get-shit-done/workflows/execute-plan.md
@/home/erinmeaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-type-safety-test-infrastructure/01-RESEARCH.md
@.planning/codebase/TESTING.md
@src/map.ts
@src/test/map.test.ts
</context>

<tasks>

<task type="auto">
  <name>Replace setTimeout in announce() with requestAnimationFrame</name>
  <files>src/map.ts</files>
  <action>
    Refactor the announce() function (lines 50-59) to use requestAnimationFrame instead of setTimeout:

    Current code:
    ```typescript
    export const announce = (message: string): void => {
      const announcer = document.getElementById('announcements');
      if (announcer) {
        announcer.textContent = '';

        setTimeout(() => {
          announcer.textContent = message;
        }, 100);
      }
    };
    ```

    Replace with:
    ```typescript
    export const announce = (message: string): void => {
      const announcer = document.getElementById('announcements');
      if (announcer) {
        announcer.textContent = '';
        requestAnimationFrame(() => {
          announcer.textContent = message;
        });
      }
    };
    ```

    Why: requestAnimationFrame ensures the DOM update (clearing textContent) is rendered before setting the new message, without arbitrary delays.

    Reference: .planning/phases/01-type-safety-test-infrastructure/01-RESEARCH.md lines 146-176

  </action>
  <verify>
    Run `npm test` - announce tests should still pass
  </verify>
  <done>
    - announce() uses requestAnimationFrame instead of setTimeout
    - No setTimeout(100) pattern remains in announce function
    - Tests pass with the new timing approach
  </done>
</task>

<task type="auto">
  <name>Replace setTimeout for layer control with Leaflet event</name>
  <files>src/map.ts</files>
  <action>
    Refactor the layer control accessibility enhancement (lines 151-167) to use Leaflet's 'add' event instead of setTimeout:

    Current code:
    ```typescript
    L.control.layers(undefined, overlays, { collapsed: false }).addTo(map);

    setTimeout(() => {
      const controlElement = document.querySelector('.leaflet-control-layers');
      if (controlElement) {
        controlElement.setAttribute('role', 'group');
        controlElement.setAttribute('aria-label', 'Map Layer Controls');

        const inputs = controlElement.querySelectorAll('input[type="checkbox"]');
        inputs.forEach((input, idx) => {
          input.setAttribute(
            'aria-label',
            idx === 0 ? 'Show Community Fridge and Pantry Locations' : 'Show Food Donation Sites'
          );
        });
      }
    }, 100);
    ```

    Replace with:
    ```typescript
    const layersControl = L.control.layers(undefined, overlays, { collapsed: false })
      .addTo(map)
      .on('add', () => {
        const controlElement = document.querySelector('.leaflet-control-layers');
        if (controlElement) {
          controlElement.setAttribute('role', 'group');
          controlElement.setAttribute('aria-label', 'Map Layer Controls');

          const inputs = controlElement.querySelectorAll('input[type="checkbox"]');
          inputs.forEach((input, idx) => {
            input.setAttribute(
              'aria-label',
              idx === 0 ? 'Show Community Fridge and Pantry Locations' : 'Show Food Donation Sites'
            );
          });
        }
      });
    ```

    Why: The 'add' event fires when the control is added to the map, guaranteeing the DOM element exists without arbitrary delays.

    Reference: .planning/phases/01-type-safety-test-infrastructure/01-RESEARCH.md lines 106-144

  </action>
  <verify>
    Run `npm test` - verify no regressions in existing tests
  </verify>
  <done>
    - Layer control uses .on('add') event handler
    - No setTimeout call remains for layer control DOM detection
    - Accessibility attributes are applied when control is added to map
  </done>
</task>

<task type="auto">
  <name>Update announce tests to use real timers</name>
  <files>src/test/map.test.ts</files>
  <action>
    Refactor announce() tests (lines 69-115) to work with real timers instead of fake timers:

    1. Remove `vi.useFakeTimers()` from beforeEach (line 76)
    2. Remove `vi.useRealTimers()` from afterEach (line 82)
    3. Replace `vi.advanceTimersByTime(100)` with `await vi.waitFor()` or simple async/await

    Updated test pattern:
    ```typescript
    describe('announce', () => {
      let announcerElement: HTMLElement;

      beforeEach(() => {
        announcerElement = document.createElement('div');
        announcerElement.setAttribute('id', 'announcements');
        document.body.appendChild(announcerElement);
      });

      afterEach(() => {
        document.body.removeChild(announcerElement);
      });

      it('should set text content on announcements element', async () => {
        announce('Test message');

        await vi.waitFor(() => {
          expect(announcerElement.textContent).toBe('Test message');
        });
      });

      it('should clear content before setting new text', async () => {
        announcerElement.textContent = 'Old message';

        announce('New message');

        // Before next frame
        expect(announcerElement.textContent).toBe('');

        await vi.waitFor(() => {
          expect(announcerElement.textContent).toBe('New message');
        });
      });
    });
    ```

    Why: With requestAnimationFrame, we need to wait for the next animation frame instead of advancing fake timers.

    Reference: .planning/phases/01-type-safety-test-infrastructure/01-RESEARCH.md lines 240-260

  </action>
  <verify>
    Run `npm test` - all tests should pass with real timers
  </verify>
  <done>
    - No vi.useFakeTimers() or vi.useRealTimers() in announce tests
    - Tests use vi.waitFor() or await for async timing
    - All tests pass with real timer behavior
  </done>
</task>

</tasks>

<verification>
After completing the tasks, verify:

1. No setTimeout: `grep -n "setTimeout" src/map.ts` returns no results
2. Tests pass: `npm test` executes successfully
3. No fake timers: `grep -n "useFakeTimers\|advanceTimersByTime" src/test/map.test.ts` returns no results
4. Event-driven patterns: Code uses whenReady, 'add' event, and requestAnimationFrame
   </verification>

<success_criteria>

1. Zero setTimeout calls in src/map.ts
2. All tests pass without fake timers
3. DOM timing uses native browser APIs (requestAnimationFrame) and Leaflet events
4. Layer control accessibility enhancements fire reliably via 'add' event
   </success_criteria>

<output>
After completion, create `.planning/phases/01-type-safety-test-infrastructure/01-02-SUMMARY.md`
</output>
